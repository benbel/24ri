<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>24e Regiment d'Infanterie - 1914-1918</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Georgia, serif; background: #f5f0e6; }
        #container { display: flex; height: 100vh; }
        #map { width: 66.666%; height: 100%; background: #fff; }
        #panel {
            width: 33.333%;
            display: flex;
            flex-direction: column;
            background: #fff;
            border-left: 1px solid #d0c8b8;
        }
        #header {
            padding: 15px 20px;
            background: #2c2416;
            color: #d4c9b0;
            font-size: 14px;
        }
        #header h1 { font-size: 16px; font-weight: normal; margin-bottom: 4px; }
        #header .date { font-size: 12px; color: #a09080; }
        #text-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            line-height: 1.8;
            font-size: 15px;
            color: #2c2416;
        }
        .paragraph { margin-bottom: 1.5em; }
        .place-name {
            background: rgba(139, 0, 0, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
        }
        .date-name {
            background: rgba(0, 100, 200, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
        }
        #nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: #f8f5ef;
            border-top: 1px solid #d0c8b8;
        }
        .nav-btn {
            background: #2c2416;
            border: none;
            color: #d4c9b0;
            padding: 10px 20px;
            cursor: pointer;
            font-family: Georgia, serif;
            font-size: 14px;
        }
        .nav-btn:hover { background: #3c3426; }
        .nav-btn:disabled { opacity: 0.3; cursor: default; }
        #progress { font-size: 12px; color: #8b7355; }
        .leaflet-tooltip {
            background: rgba(44,36,22,0.9);
            border: none;
            color: #f5f0e6;
            font-family: Georgia, serif;
            padding: 4px 8px;
        }
        .leaflet-tooltip-top:before { border-top-color: rgba(44,36,22,0.9); }
    </style>
</head>
<body>
    <div id="container">
        <div id="map"></div>
        <div id="panel">
            <div id="header">
                <h1 id="chapter-title">-</h1>
                <div class="date" id="current-date">-</div>
            </div>
            <div id="text-container"></div>
            <div id="nav">
                <button class="nav-btn" id="prev-btn">&larr; Precedent</button>
                <span id="progress">-</span>
                <button class="nav-btn" id="next-btn">Suivant &rarr;</button>
            </div>
        </div>
    </div>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const chunks = {{ chunks_json | safe }};
        let currentIndex = 0;
        let map;
        let markers = [];
        let pathLine = null;
        let pathCoords = [];

        function initMap() {
            map = L.map('map', { zoomControl: false }).setView([48.8, 2.5], 6);

            // IGN Carte Etat-Major (WMTS)
            L.tileLayer('https://data.geopf.fr/wmts?' +
                'SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0' +
                '&LAYER=GEOGRAPHICALGRIDSYSTEMS.ETATMAJOR40' +
                '&STYLE=normal' +
                '&FORMAT=image/jpeg' +
                '&TILEMATRIXSET=PM' +
                '&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
                maxZoom: 16,
                attribution: 'IGN'
            }).addTo(map);

            showChunk(0);
        }

        function clearMarkers() {
            markers.forEach(m => map.removeLayer(m));
            markers = [];
        }

        function drawPath() {
            // Draw solid path without arrows
            if (pathCoords.length < 2) return;

            if (pathLine) map.removeLayer(pathLine);

            pathLine = L.polyline(pathCoords, {
                color: '#8b0000',
                weight: 3,
                opacity: 0.8
            }).addTo(map);
        }

        function showChunk(index) {
            if (index < 0 || index >= chunks.length) return;
            currentIndex = index;

            const chunk = chunks[index];
            document.getElementById('progress').textContent = `${index + 1} / ${chunks.length}`;
            document.getElementById('prev-btn').disabled = index === 0;
            document.getElementById('next-btn').disabled = index === chunks.length - 1;

            // Update header
            document.getElementById('chapter-title').textContent =
                `Chapitre ${chunk.chapter_number}: ${chunk.chapter_title}`;
            document.getElementById('current-date').textContent = chunk.date || '';

            // Render chunk text with highlighted places
            renderText(chunk);

            // Update map if we have places
            if (chunk.places && chunk.places.length > 0) {
                updateMap(chunk);
            }
        }

        function renderText(chunk) {
            const container = document.getElementById('text-container');
            const text = chunk.text || '';
            const places = chunk.places || [];
            const dates = chunk.dates || [];

            let html = text;

            // Deduplicate and sort dates by length (longest first)
            const uniqueDates = [...new Set(dates)].sort((a, b) => b.length - a.length);

            // Replace dates with highlighted versions
            uniqueDates.forEach(d => {
                const escaped = d.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                html = html.replace(
                    new RegExp(`(${escaped})(?![^<]*>)`, 'gi'),
                    '<span class="date-name">$1</span>'
                );
            });

            // Deduplicate and sort places by text length (longest first)
            const placeTexts = [...new Set(places.map(p => p.text))].sort((a, b) => b.length - a.length);

            // Replace place names with highlighted versions
            placeTexts.forEach(name => {
                const escaped = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                html = html.replace(
                    new RegExp(`(${escaped})(?![^<]*>)`, 'gi'),
                    '<span class="place-name">$1</span>'
                );
            });

            container.innerHTML = `<div class="paragraph">${html}</div>`;
            container.scrollTop = 0;
        }

        function updateMap(chunk) {
            clearMarkers();

            const places = chunk.places.filter(p => p.geocoded);
            if (places.length === 0) return;

            const bounds = [];

            // Add new points to path
            places.forEach(p => {
                const lat = p.geocoded.latitude;
                const lon = p.geocoded.longitude;
                pathCoords.push([lat, lon]);
                bounds.push([lat, lon]);
            });

            // Draw solid path (no arrows)
            drawPath();

            // Add markers for current chunk's places
            places.forEach(p => {
                const lat = p.geocoded.latitude;
                const lon = p.geocoded.longitude;
                const name = p.display_name || p.text;

                const marker = L.circleMarker([lat, lon], {
                    radius: 8,
                    fillColor: '#8b0000',
                    color: '#fff',
                    weight: 2,
                    fillOpacity: 0.9
                }).addTo(map);

                marker.bindTooltip(name, { permanent: true, direction: 'top', offset: [0, -8] });
                markers.push(marker);
            });

            // Fit bounds
            if (bounds.length === 1) {
                map.setView(bounds[0], 11, { animate: true });
            } else {
                map.fitBounds(bounds, { padding: [60, 60], maxZoom: 12, animate: true });
            }
        }

        function next() {
            if (currentIndex < chunks.length - 1) {
                showChunk(currentIndex + 1);
            }
        }

        function prev() {
            if (currentIndex > 0) {
                // Remove last places from path
                const chunk = chunks[currentIndex];
                if (chunk.places) {
                    const count = chunk.places.filter(p => p.geocoded).length;
                    pathCoords = pathCoords.slice(0, -count);
                }
                showChunk(currentIndex - 1);
            }
        }

        // Event listeners
        document.getElementById('prev-btn').onclick = prev;
        document.getElementById('next-btn').onclick = next;

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') { e.preventDefault(); prev(); }
            if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ') { e.preventDefault(); next(); }
        });

        let wheelTimeout = null;
        document.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) return;
            if (e.target.closest('#text-container')) return; // Allow scroll in text
            e.preventDefault();
            if (wheelTimeout) return;
            wheelTimeout = setTimeout(() => { wheelTimeout = null; }, 300);
            if (e.deltaY > 0) next(); else prev();
        }, { passive: false });

        document.addEventListener('DOMContentLoaded', initMap);
    </script>
</body>
</html>
